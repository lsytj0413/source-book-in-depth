# <Effective Python 读书笔记> #

[《Effective Python》](https://book.douban.com/subject/26312313/) 是由 [Brett Slatkin](https://github.com/bslatkin)  撰写的, 讲述如何以符合Python风格的 (Pythonic) 方式来编写程序. 
书中的每一个条目都是一项独立的教程, 并包含它自己的源代码, 给出了相当精炼而又符合主流观点的建议.

以下是各章节的内容:

- [第一章: 用Pythonic方式思考](./chapter01.md)

    - 第1条: 确认自己所用的Python版本
    - 第2条: 遵循PEP8风格指南
    - 第3条: 了解bytes, str和unicode的区别
    - 第4条: 用辅助函数来取代复杂的表达式
    - 第5条: 了解切割序列的方法
    - 第6条: 在单次切片操作中, 不要同时指定start, end和stride
    - 第7条: 用列表推导来取代map和filter
    - 第8条: 不要使用含有两个以上表达式的列表推导
    - 第9条: 用生成器表达式来改写数据量较大的列表推导
    - 第10条: 尽量使用enumerate取代range
    - 第11条: 用zip函数同时遍历两个迭代器
    - 第12条: 不要在for和while循环后面写else块
    - 第13条: 合理利用try/except/else/finally结构中的每个代码块

- [第二章: 函数](./chapter02.md)

    - 第14条: 尽量用异常来表示特殊情况, 而不要返回None
    - 第15条: 了解如何在闭包里使用外围作用域中的变量
    - 第16条: 考虑用生成器来改写直接返回列表的函数
    - 第17条: 在参数上面迭代时, 要多加小心
    - 第18条: 用数量可变的位置参数减少视觉杂讯
    - 第19条: 用关键字参数来表达可选的行为
    - 第20条: 用None和文档字符串来描述具有动态默认值的参数
    - 第21条: 用只能以关键字形式指定的参数来确保代码明晰

- [第三章: 类与继承](./chapter03.md)

    - 第22条: 尽量用辅助类来维护程序的状态, 而不要用字典和元组
    - 第23条: 简单的接口应该接受函数, 而不是类的实例
    - 第24条: 以 @classmethod形式的多态去通用地构建对象
    - 第25条: 用super初始化父类
    - 第26条: 只在使用Mix-in组件制作工具类时进行多重继承
    - 第27条: 多用public属性, 少用private属性
    - 第28条: 继承collections.abc 以实现自定义的容器类型

- [第四章: 元类及属性](./chapter04.md)

    - 第29条: 用纯属性取代get和set方法
    - 第30条: 考虑用 @property 来替代属性重构
    - 第31条: 用描述符来改写需要复用的 @property 方法
    - 第32条: 用 \_\_getattr\_\_, \_\_getattribute\_\_ 和 \_\_setattr\_\_ 实现按需生成的属性
    - 第33条: 用元类来验证子类
    - 第34条: 用元类来注册子类
    - 第35条: 用元类来注解类的属性

- [第五章: 并发及并行](./chapter05.md)

    - 第36条: 用subprocess模块来管理子进程
    - 第37条: 可以用线程来执行阻塞式I/O, 但不要用它做平行计算
    - 第38条: 在线程中使用Lock来防止数据竞争
    - 第39条: 用Queue来协调各线程之间的工作
    - 第40条: 考虑用协程来并发地运行多个函数
    - 第41条: 考虑用concurrent.futures来实现真正的并行计算

- [第六章: 内置模块](./chapter06.md)

    - 第42条: 用functools.wraps定义函数修饰器
    - 第43条: 考虑以contextlib和with语句来改写可复用的try/finally代码
    - 第44条: 用copyreg实现可靠的pickle操作
    - 第45条: 应该用datetime模块来处理本地时间, 而不是用time模块
    - 第46条: 使用内置算法与数据结构
    - 第47条: 在重视精确度的场合, 应该使用decimal
    - 第48条: 学会安装由Python开发者社区所构建的模块

- [第七章: 协作开发](./chapter07.md)

    - 第49条: 为每个函数, 类和模块编写文档字符串
    - 第50条: 用包来安排模块, 并提供稳固的API
    - 第51条: 为自编的模块定义根异常, 以便将调用者与API相隔离
    - 第52条: 用适当的方式打破循环依赖关系
    - 第53条: 用虚拟环境隔离项目, 并重建其依赖关系

- [第八章: 部署](./chapter08.md)

    - 第54条: 考虑用模块级别的代码来配置不同的部署环境
    - 第55条: 通过repr字符串来输出调试信息
    - 第56条: 用unittest来测试全部代码
    - 第57条: 考虑用pdb实现交互调试
    - 第58条: 先分析性能, 然后再优化
    - 第59条: 用tracemalloc来掌握内存的使用及泄漏情况
