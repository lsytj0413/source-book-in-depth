# 第十九章: 正则表达式 #

## 19.1 什么是正则表达式 ##

正则表达式是一种符号表示法, 用于识别文本模式. 类似与匹配文件和路径时使用的 shell通配符, 但是用途更为广泛.

## 19.2 grep-文本搜索 ##

我们用来处理正则表达式的主要程序是grep, grep搜索文本文件中与指定正则表达式匹配的行, 并将结果送至标准输出.

```
# 搜索 /usr/bin下名称包含zip字符串的所有文件
ls /usr/bin | grep zip
```

grep命令的格式如下:

```
grep [options] regex [file...]
```

grep常用的选项如下表:

| 选项 | 功能描述 |
| :-- | :-- |
| -i | 忽略大小写, 同 --ignore-case |
| -v | 不匹配, 正常情况下grep会输出匹配行, 该选项可让grep 输出不匹配行, 同 --invert-match |
| -c | 输出匹配项数目而不是匹配行自身, 同 --count |
| -l | 输出匹配项文件名, 同 --files-with-matches |
| -L | 类似 -l 选项, 输出不包含匹配项的文件名, 同 --files-without-match |
| -n | 在每个匹配行前加上行号, 同 --line-number |
| -h | 进行多文件搜索时, 抑制文件名的输出, 同 --no-filename |

## 19.3 元字符和文字 ##

正则表达式 bzip 用于匹配文本中至少包含4个字符, 存在连续的按bzip顺序组成的字符串的行. 字符串bzip中的字符都是文字字符, 即它们只能与自身进行匹配.
除了文字字符, 正则表达式还可以包含用于指定更为复杂的匹配的元字符. 正则表达式的元字符包括以下字符:

```
^ $ . [ ] { } - ? * + ( ) | \
```

其他所有字符都被当作文字字符, 在极少数的情况下反斜杠字符用来创建元序列, 以及用来对元字符进行转义, 使其成为文字字符.

## 19.4 任意字符 ##

元字符中的点字符可以用于匹配任意字符.

```
grep -h '.zip' dirlist*.txt
```

## 19.5 锚 ##

插入符[\^] 和美元符号[$] 在正则表达式中被当作锚, 插入符匹配行的开头, 美元符号匹配行的末尾.

```
grep -h '^zip' dirlist*.txt
grep -h 'zip$' dirlist*.txt
grep -h '^zip$' dirlist*.txt
```

其中 [\^$] 会匹配空行.

## 19.6 中括号表达式和字符类 ##

中括号除了可以匹配正则表达式中给定位置的任意字符外, 还可以用于匹配指定字符集中的单个字符, 我们可以指定要匹配的字符集, 包括元字符的字符.

```
grep -h '[bg]zip' dirlist*.txt
```

一个字符集可以包含任意数目的字符, 并且当元字符放置到中括号中时会失去它们的特殊含义, 但是插入符在中括号中表示否定, 连字符表示字符范围.

### 19.6.1 否定 ###

如果中括号内的第一个字符是插入符, 那么剩下的字符被当作不应该在指定位置出现的字符集.

```
grep -h '[^bg]zip' dirlist*.txt
```
插入符只有在中括号表达式中是第一个字符时才代表否定符, 否则将失去特殊含义成为普通字符.

### 19.6.2 传统字符范围 ###

通过连字符可以使用三个字符来表示字符范围.

```
grep -h '^[A-Za-z0-9]' dirlist*.txt
```
当连字符出现在中括号表达式中的第一个字符时, 将失去其特殊意义成为普通字符.

### 19.6.3 POSIX字符类 ###

传统的字符范围表示方式不是所有情况的通用.

```
ls /usr/sbin/[ABCDEFGHIJKLMNOPQRSTUVWXYZ]*
ls /usr/bin/[A-Z]*
```
上述的命令在不同的系统下可能得到不同的结果.

原因是: 在UNIX开发的初期, 它只识别ASCII字符. 在ASCII字符中, 前32个字符都是控制字符, 后32个字符包含可打印字符,
接下来的32个字符包含大写字母和一些标点符号, 最后31个则包含小写字母以及更多的标点符号. ASCII系统使用如下的排序:

```
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrtsuvwxyz
```
这与通常的字典顺序不同, 字典顺序如下:

```
AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz
```

随着UNIX的普及, ASCII字符表也得到扩展, 开始使用8位二进制来表示. 为了支持这种功能, POSIX标准引入了域(locale) 的概念, 它通过不停的调整以选择特定的位置需要的字符集.
可以使用如下命令查看系统的语言设置:

```
echo $LANG
```

有了这个设置, POSIX兼容应用使用的便是字典顺序, 所以使用 [A-Z] 时的字符集是除了小写字母a之外的所有字母, 而不是预期的大写字母的合集.
为了解决这个问题, POSIX标准包含了许多标准字符类, 常用的如下表:

| 字符类 | 描述 |
|:--|:--|
| [:alnum:] | 字母字符和数字字符, 等价于 [A-Za-z0-9] |
| [:word:] | 同 [:alnum:], 多一个下划线字符 |
| [:alpha:] | 字母字符 |
| [:blank:] | 包括空格和制表符 |
| [:cntrl:] | ASCII控制码, 包含字符中的0-31以及127 |
| [:digit:] | 数字 0-9 |
| [:graph:] | 可见字符, 包含ASCII字符中的 33-126 |
| [:lower:] | 小写字母 |
| [:punct:] | 标点符号字符 |
| [:print:] | 可打印字符, 同 [:graph:] 加上空格字符 |
| [:space:] | 空白字符, 如空格, 制表符, 回车符, 换行符等 |
| [:upper:] | 大写字母 |
| [:xdigit:] | 用于表示十六进制的字符, 同 [0-9A-Fa-f] |

使用字符类重写上面的例子:

```
ls /usr/sbin/[[:upper:]]*
```

注意: 上述的并不是一个正则表达式示例, 而是shell路径名扩展的例子.

## 19.7 POSIX基本正则表达式和扩展正则表达式的比较 ##

POSIX规范将正则表达式分为了两种: 基本正则表达式(BRE)和扩展正则表达式(ERE).

它们的区别是支持的元字符不同. BRE只支持如下的元字符:

```
^ $ . [ ] *
```
ERE中则添加了下面的元字符:

```
( ) { } ? + |
```

在添加转义的情况下, 小括号和大括号字符被BRE识别为元字符, 在ERE中, 任何元字符前添加反斜杠转义都会使其被当作文字字符处理.

如果要使用ERE的特性, 传统上需要由 egrep命令执行, 但是GNU版本的grep命令可以使用 -E 选项支持ERE方式.

## 19.8 或选项 ##

或选项用于从字符串集或正则表达式集中寻找匹配项.

```
echo "AAA" | grep -E 'AAA|BBB|CCC'
```
这里的正则表达式的含义是匹配AAA或BBB 或 CCC . 

可以用小括号将或选项的元素与其他符号隔开:

```
grep -Eh '^(bz|gz|zip)' dirlist*.txt
```

## 19.9 限定符 ##

ERE提供多种方法指定某元素匹配的次数.

### 19.9.1 ?-匹配某元素0次或1次 ###

该限定符意味着前面的元素可选.
例如想检查某电话号码的有效性, 格式为 (nnn) nnn-nnnn 和 nnn nnn-nnnn 两种. 正则表达式如下:

```
^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$
```

### 19.9.2 *-匹配某元素多次或0次 ###

该限定符用于表示一个可选择的条目, 该条目可以多次出现.
例如检查一串字符是否是一句话, 即该字符是以大写字母开头而以句号结束, 中间是任意数目的大小写字母和空格, 正则表达式如下:

```
[[:upper:]][[:upper:][:lower:] ]*\.
```

### 19.9.3 +-匹配某元素多次或1次 ###

该限定符意味着前面的元素至少出现一次.
例如检查由单个空格分割的一个或多个字母字符组成的行:

```
^([[:alpha:]]+ ?)+$
```

### 19.9.4 {}-以指定次数匹配某元素 ###

该元字符用于描述最小和最大次数的需求匹配, 可以通过4中方法来指定, 如下表:

| 指定项 | 含义 |
|:--|:--|
| {n} | 恰好出现n次 |
| {n,m} | 出现的次数在n~m 之间 |
| {n,} | 出现的次数超过n次 |
| {,m} | 出现的次数不超过m次 |

例如可以将电话号码的例子修改如下:

```
^\([0-9]{3}\)? [0-9]{3}-[0-9]{4}$
```

## 19.10 正则表达式的应用 ##

### 19.10.1 用grep命令验证号码簿 ###

首先创建一个号码列表:

```
for i in {1..10}; do echo "(${RANDOM:0:3}) ${RANDOM:0:3}-${RANDOM:0:4}" >> phonelist.txt; done
```
该命令行会产生一个包含10个电话号码的名为 phonelist.txt 的文件.

然后利用grep判断有效性:

```
grep -Ev '^\([0-9]{3}\)? [0-9]{3}-[0-9]{4}$' phonelist.txt
```

### 19.10.2 用find查找奇怪文件名的文件 ###

find命令的test选项可以使用正则表达式, 当运用正则表达式时, find要求文件名与指定表达式完全一致.

例如, 查找文件名中包含空格以及其他潜在不规范字符的文件:

```
find . -regex '.*[^-_./0-9a-zA-Z].*'
```

### 19.10.3 用locate查找文件 ###

locate命令即支持基本正则表达式(--regexp选项), 也支持扩展正则表达式(--regex 选项).

```
locate --regex 'bin/(bz|gz|zip)'
```

### 19.10.4 利用less和vim命令搜索文件 ###

在less和vim中, 可以键入正则表达式进行搜索. vim也支持基本正则表达式.

## 19.11 本章结尾语 ##

可以通过以下方式查找手册页中提示到正则表达式的内容:

```
cd /usr/share/man
zgrep -E1 'regex|regular expression' *.gz
```
在上面的命令中使用 zgrep 以便对压缩文件进行搜索.

## 19.11 扩展阅读 ##

有许多在线学习正则表达式的资源, 包括各种各样的教材和速记表. 另外, 关于下面的背景话题, Wikipedia 有不错的文章:

- POSIX: [http://en.wikipedia.org/wiki/Posix](http://en.wikipedia.org/wiki/Posix) 

- ASCII: [http://en.wikipedia.org/wiki/Ascii](http://en.wikipedia.org/wiki/Ascii)
